---
layout: post
title:  "SSE vs Websocket"

[//]: # (date:   2023-01-02 21:34:36 +0900)

categories: IT
---

[//]: # (<h1>Introduction</h1>)

### SSE와 Websocket

#### 1. Websocket 웹소켓

웹소켓은 HTTP와 같은 통신 프로토콜의 일종으로, 서버와 클라이언트 간의 효율적 양방향 통신을 실현하기 위한 구조이다.   
단순한 API로 구성되어 있으며, 브라우저는 서버가 직접 보내는 데이터를 받아들일 수 있고, 새로고침 및 다른 페이지로 이동하지 않아도 최신 데이터를 확인할 수 있다는 장점이 있다.   
따라서 채팅, 게임, 차트 등 실시간으로 데이터를 확인해야 하는 기능의 효과적인 구현이 가능하다.

#### 1.1. Websocket의 작동 원리
웹소켓 역시 HTTP 프로토콜을 이용해 이루어진다. 연결이 정상적으로 이루어진다면 서버와 클라이언트 간의 웹소켓 연결(TCP/IP)이 이루어지고, 일정 시간이 흐르면 HTTP연결은 자동으로 끊어진다.

#### 1.2. Websocket의 문제점
- 웹소켓은 상태 프로토콜이기 때문에 서버와 클라이언트 간의 연결을 항상 유지해야 하며, 비정상적으로 연결이 끊겼을 경우 적절히 대응해야 한다. 이는 기존의 HTTP 사용 시와 비교했을 때 코딩의 복잡성을 가중시키는 요인이 될 수 있다.
- 서버와 클라이언트 간의 연결을 유지하는 것 자체가 비용이 든다. CPU에 부담이 될 수 있다.
- 오래된 버전의 웹 브라우저에서는 지원하지 않는다.


#### 2. SSE(Server-Sent-Events)

SSE는 웹소켓과 달리 클라이언트가 서버로부터 데이터만 받을 수 있는 단방향 방식의 HTML5 표준 기술이다.   
서버와 한번 연결을 맺고나면 일정 시간동안 서버에서 변경이 발생할 때마다 데이터를 전송받는 방법으로, 별도의 프로토콜을 사용하지 않고 HTTP 프로토콜만으로 사용할 수 있기 때문에 구현이 용이하다.   
즉, 작동하려면 특별한 프로토콜이나 서버 구현이 필요하지 않다.   


지금 진행 중인 프로젝트에서는 서버로부터 일정 데이터를 실시간으로 받아오는 기능이 필요했다.   
그 전까지 데이터를 받아오는 방식은 매 5초마다 서버에 요청하여 데이터를 받아오는 형식이었는데,   
이 방식은 애초에 실시간도 아닐 뿐더러(실시간처럼 보이게 해놨을 뿐) 많은 비용 및 과부하를 야기하고 변경된 사항이 없음에도 계속해서 정보를 새로 받아와야 한다는 문제가 있었다.   
이를 해결하기 위해 SSE를 적용하기로 했다.



### SSE 구현해보기

이벤트 스트림을 구독하려면 EventSource 객체를 만들고, 스트림의 URL을 전달해야 한다.
우선 클라이언트에서는 EventSource라는 인터페이스로 SSE 연결 요청을 할 수 있다.

    const eventSource = new EventSource(`URL넣기`)

그런 다음 메시지 이벤트에 대한 핸들러를 설정해야한다. 


    eventSource.onopen = (evt) => {
        console.log('onopen', evt)
    }
    eventSource.onmessage = (event) => {
        console.log(event)
    }
    eventSource.addEventListener('이벤트 명', (evt) => {
        const data = JSON.parse(evt.data)
        console.log(data)
    })


맨 처음 서버와 연결이 되면 onopen 함수가 실행되어 console에서 해당 데이터를 확인할 수 있다.
그 후, 서버에서 업데이트된 내용이 푸시되면 onmessage 함수가 실행되고 e.data 속성에서 새 데이터를 사용할 수 있게 된다.   
단, 특정한 이벤트 명이 설정되어 오는 경우 addEventListener를 사용하여 해당 이벤트 이름으로 오는 데이터를 확인 가능하다.
